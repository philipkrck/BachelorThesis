\chapter{Flutter}
The goal of this chapter is to first contextualize Flutter's unique approach within other cross-platform techniques.\\
This overview of mobile development approaches (Section \ref{section::other_architectures}) forms the basis for a further explaination of Flutter's architecture (Section \ref{section::flutter_architecture}).
On the one hand, the exploration of Flutter's architectural overview aids as the basis for understanding certain implementation choices regarding the Flutter clone (detailed in Chapter \ref{chapter::implementation}).
On the other hand, the technicalities of Flutter's architecture are utilized to explain certain results (Chapter \ref{chapter::results}) of the performed study (detailed in Chapter \ref{chapter::study_design}).

\section{Mobile Development Approaches} \label{section::other_architectures}
The following subsections depict the individual mobile development approaches (derived from \cite{Heitkoetter2013} and \cite{Cunha2018}).
Generally, each approach can be placed along a spectrum of being built with web technologies on one and native technologies on the other end (see Figure \ref{fig::mobile_development_approach_spectrum}).\\
\begin{figure}
    \includegraphics[width=\linewidth]{images/architectures/mobile_development_approaches.eps}
    \caption{Mobile Development Approach Spectrum}
    \label{fig::mobile_development_approach_spectrum}
\end{figure}


\subsection{Web Apps and Progressive Web Apps} \label{subsection::web_apps}
Web apps are run and rendered in the browser. The underlying technologis are HTML, CSS and JavaScript with popular frameworks 
used for the development process such as Angualar (\cite{Angular2021}), React.js (\cite{React2021}) and Vue.js (\cite{Vue2021}). Web apps rely on the Browser and an internet connection.
They do not have direct access to hardware capabilites such as the camera or the file system.\\
Progressive Web Apps (PWAs) function similarly to web apps but provide additional capabilities such as offline use, locally cached data, 
push notifications, and the ability to add them to the home screen. However, the feature set of PWAs is limited to the functionality exposed through the underlying browser.

\subsection{Hybrid Apps}
Hybrid Apps utilize the same technologies as web apps (see Subsection \ref{subsection::web_apps}), but they are rendered in a platform web view (see Figure \ref{fig:hybrid_architecture}). Additionally they provide the ability to 
interact with native APIs such as GPS and sensor data through a platform bridge (see Figure \ref{fig:hybrid_architecture}).
Unlike web apps, hybrid apps are shippable through official stores.
Popular framework choices for building Hybrid Apps include Ionic (\cite{Ionic2021}) and Cordova (\cite{Cordova2020}).

\begin{figure}
    \includegraphics[width=\linewidth]{images/architectures/hybrid_architecture.eps}
    \caption{Hybrid architecture (image to be replaced).}
    \label{fig:hybrid_architecture}
\end{figure}

\subsection{Web Native Apps} \label{subsection::web_native_apps}
Web Native Apps utilize the OEM components instead of web views for UI rendering while primarily using JavaScript.
This is achieved by using a platform bridge for the transpilation of JavaScript into native platform code allowing for OS level user interface component [Einsatz]
and system services calls. 
Frameworks for building web native apps include React Native (\cite{ReactNative2021}) and Native Script (\cite{NativeScript2021}).

\begin{figure}
    \includegraphics[width=\linewidth]{images/architectures/native_web_app_architecture.eps}
    \caption{Web Native and Cross Compiled Architecture (adapted from source) (image to be replaced).}
    \label{fig:web_native_architecture}
\end{figure}

\subsection{Cross Compiled Apps}
Generally, cross compiled apps [utilize] UI components and services from the underlying host platform similar to web native apps (see Subsection \ref{subsection::web_native_apps} and Figure \ref{fig:web_native_architecture}).
The OS plugin mechanism works by executing generated byte or machine code on the target device from a compiled language such as C\# (used for Xamarin, \cite{Xamarin2021}).\\
Flutter may be classified as a cross compilation based approach. However, it uniquely leaves the UI rendering process to its \textbf{Skia} graphics engine.
The frameworks technicalities are further explained in Section \ref{section::flutter_architecture}.

\begin{figure}
    \includegraphics[width=\linewidth]{images/architectures/flutter_architecture.eps}
    \caption{Flutter Architecture (image to be replaced).}
    \label{fig:flutter_architecture}
\end{figure}

\subsection{Native Mobile Applications}
Native applications directly communicate with the OEM components and APIs which are part of the operating system and thus tightly integrated into the platform.
Making full use of hardware and software integration, native apps yield the highest performance and user experience.

\begin{figure}
    \includegraphics[width=\linewidth]{images/architectures/native_architecture.eps}
    \caption{Native Mobile Architecture (image to be replaced).}
    \label{fig:native_architecture}
\end{figure}

\section{Flutter Framework Architecture} \label{section::flutter_architecture}
Flutter's framework architecture is composed of three distinct layers: framework, engine and embedder. The framework acts as the top most layer which 
app developers interact with. It features the widgets, animation and gestures API as well as platform specific UI components delivered through
the Material (Android) and Cupertino (iOS) package.

Below the framework layer lies the engine which unlike the framework isn't written in Dart, but in C and C++. Presumably, this design choice has been 
made to easily allow the production of native binaries. This act of cross-compilation is Flutter's technical value proposition to increase execution performance as stated in 
Section \ref{section:introduction}. The engine layer includes Skia - a 2D graphics rendering engine which is also used in the Chrome web browser.

At the bottom lies the embedder layer. Its sole purpose is to integrate the Flutter application into the platform-specific environment
by providing native plugins and event loop interoperation. 
Additionally, app package formatting is provided in the same way as for native apps. 
The host operating is thus not able to differentiate between a Flutter and a natively written app.
Flutter aims to minimize application size as it's already shipping the entire framework including the rendering engine with each app which amounts
to approximately 4.5 mb (https://flutter.dev/docs/resources/faq). Common app platform plugin functionality like camera access or webview 
interaction are extracted in separate packages. Networking, animations or other platform agnostic functionality is also bundled in packages. 

(ref to include https://flutter.dev/docs/resources/architectural-overview).
\begin{figure}
    \includegraphics[width=\linewidth]{images/flutter_layered_architecture.eps}
    \caption{Flutter's Layered Architecture}
    \label{fig:flutter_layered_architecture}
\end{figure}


\subsection{Programming Language and Compilation}
Flutter apps are written in Dart an multiparadigm programming language syntactically similar to Java. (https://dart.dev/overview\#language)

During Flutter development, apps run in the Dart Virtual Machine with JIT compilation. This offers stateful hot reload which allows reload changes without needing 
to fully recompile the app leading faster development iteration.
For release purposes, Flutter applications are Ahead-of-Time compiled into native machine code including the Intel x86 and ARM instruction sets.
(https://flutter.dev/docs/resources/architectural-overview).


\subsection{Rendering and UI State}
Flutter apps are fundamentally composed of widgets which declare structural, stylistic and layout elements for building the user interface. 
Each widget may have 0, 1 or multiple children which in turn create a tree structure of parent-child relationships. 
For example, a Column which has the purpose of laying out its children vertically has both a Text and an Image as its children. Both the Text,
and Image widgets have no children and represent the leaf nodes in the tree. The Column is an invisible structural layout element while Text and 
Image are stylistic.
\footnote{Technically both Text and Image do have an implicit single child widget which is created by the framework.}
The entry point of every Flutter app is either a 'MaterialApp' or 'CupertinoApp' widget which also marks the root of the tree.
Based on this tree structure Flutter can determine where and how elements should be drawn on screen, and instruct its graphics engine accordingly.
This concept alone is not yet sufficient to enable modern mobile applications with complex UI changes or animations 
based on asynchronous events like user interaction. 
Widgets are mappings from state to a UI representation. When the state changes during runtime Flutter creates a new widget tree, 
diffs it against the old one and then redraws only its changes to the screen.
This declarative approach simplifies UI development in the sense that the developer does not need to keep track of UI state which can grow exponentially
with the increase of UI components on screen. 

\subsection{Method Channels}
To utilize platform functionality like camera access, geolocation or other sensor data, Flutter communicates with the platform's native APIs via 
method channels (see architecture diagram). Common functionality is already provided by Flutter and third party packages, but custom platform channel
functionality may be implemented as required. (reference Flutter doucmentation...)

\section{Flutter's Limitations}
Unlike other cross-platform frameworks, Flutter doesn't use OEM components, but its own components instead (widgets).
When the underlying OEM component of the host platform changes with an OS update, Flutters' framework needs to updated to resemble this new 
functionality. Flutter always has to continuously replicate these changes in their framework layer. As Google is using Flutter itself in multiple 
production apps (cite something), the company has an incentive to swiftly replicate OS features. Additionally, since Google also owns Android, 
coordination may be easier and not as surprising.
The benefit though is that once the new widget is rebuilt in Flutter it can even be shipped to older operating systems.